# A practical Apperception Engine

This is an implementation of an **Apperception Engine** written *de novo* in Prolog + CHR. It is based on the original Apperception Engine of Richard Evans et al. described in the paper ["Making Sense of Sensory Input"](https://arxiv.org/abs/1910.02227).

An Apperception Engine is a system that analyzes sequences of observations and infers causal theories that explain them. The engine operates by iteratively searching through a space of possible theories (doing unsupervised logic program induction), evaluating their adequacy and conciseness, and retaining the best ones based on the search criteria.

The aim is to generate "good enough" causal theories "quickly enough" to support cognitive processes.

## Core Functionality

The engine's primary predicate, `apperceive/3`, takes a sequence of observations, a set of constraints (`ApperceptionLimits`), and outputs the best causal theories (`Theories`).

The process begins by initializing parameters such as the search deadline and the maximum number of theories to retain. The observations are converted into a trace format, which allows the engine to compare them against traces generated by candidate theories.

The search space is divided into "regions" of increasing complexity, and within each region, templates are used to generate candidate theories. These templates define the structure of the theories and are evaluated iteratively.

## Constraint Handling with CHR

The engine uses **Constraint Handling Rules (CHR)** to manage constraints during the search process. CHR is a declarative language extension for writing constraint solvers. In this code, CHR constraints are used to track deadlines, manage templates, and enforce limits on the number of theories. For example:

- The `deadline/1` constraint ensures that the search terminates when the allotted time expires.
- The `region_templates_count/1` constraint tracks the number of templates processed in a region.

These constraints allow the engine to efficiently manage resources and enforce search limits.

## Theory Evaluation and Selection

Theories are evaluated based on their **coverage** (how well they explain the observations) and **complexity** (how simple they are). The engine applies heuristics to retain only the most promising theories, discarding redundant or low-quality ones. If a theory achieves a "good enough" coverage, the search halts early, and the theory is returned as the result. This optimization ensures that the engine can provide timely results, even if the search space is vast.

## Iterative Search and Concurrency

The search process is iterative, with each iteration refining the set of candidate theories. The engine uses a "funnel" mechanism to progressively narrow the search space by reducing the number of templates considered in each iteration. Additionally, the engine leverages concurrency to speed up the search, processing multiple templates in parallel using Prolog's `concurrent/3` predicate. This parallelism is particularly useful for handling large search spaces efficiently.

## Observations and Traces

The engine converts sequences of observations into a trace format to facilitate comparison with traces generated by candidate theories. This conversion allows the engine to match the observed data against the predictions made by candidate theories, enabling it to evaluate their accuracy.

## Error Handling and Termination

The engine includes robust error handling to manage exceptions that may occur during the search. For example:

- If the search time expires, the engine gracefully terminates and returns the best theories discovered so far.
- If a perfect theory is found, the search halts early.

This ensures that the engine can operate reliably under various conditions.

## Summary

In summary, this code implements a performant system for causal reasoning based on sequences of observations. It combines adbuctive inferencing (CHR), iterative search, and concurrency to efficiently explore a large space of possible theories. The engine is designed to balance accuracy and computational efficiency, making it suitable for real-time applications in cognitive systems.
